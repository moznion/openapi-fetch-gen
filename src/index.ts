import path from "node:path";
import {
  type InterfaceDeclaration,
  ModuleKind,
  Node,
  Project,
  ScriptTarget,
  type SourceFile,
} from "ts-morph";

/**
 * Generates a TypeScript API client using openapi-fetch based on TypeScript interface definitions
 * generated by openapi-typescript.
 */
export function generateClient(schemaFilePath: string): string {
  const project = new Project({
    compilerOptions: {
      target: ScriptTarget.Latest,
      module: ModuleKind.ESNext,
    },
  });
  const schemaFile = project.addSourceFileAtPath(schemaFilePath);

  const pathsInterface = findInterface(schemaFile, "paths");
  if (!pathsInterface) {
    throw new Error(`Interface "paths" not found in ${schemaFilePath}`);
  }

  return generateClientCode(pathsInterface, path.basename(schemaFilePath));
}

function findInterface(
  sourceFile: SourceFile,
  interfaceName: string,
): InterfaceDeclaration | undefined {
  return sourceFile.getInterfaces().find((i) => i.getName() === interfaceName);
}

interface EndpointInfo {
  path: string;
  httpMethod: string;
  operationName: string;
  commentLines: string[];
  paramsType: string | null;
  bodyType: string | null;
}

function generateClientCode(
  pathsInterface: InterfaceDeclaration,
  schemaFileName: string,
): string {
  const endpoints = extractEndpointsInfo(pathsInterface);

  const clientClass = generateClientClass(endpoints);

  return [
    `import createClient, { type ClientOptions } from "openapi-fetch";`,
    `import type { paths } from "./${schemaFileName.replace(/\.d\.ts$/, "")}"; // generated by openapi-typescript`,
    "",
    clientClass,
  ].join("\n");
}

function extractEndpointsInfo(
  pathsInterface: InterfaceDeclaration,
): EndpointInfo[] {
  const endpoints: EndpointInfo[] = [];

  for (const property of pathsInterface.getProperties()) {
    const path = property.getName().replace(/['"]/g, "");
    const propertyType = property.getType();

    const httpMethods = [
      "get",
      "post",
      "put",
      "delete",
      "patch",
      "head",
      "options",
    ];

    for (const httpMethod of httpMethods) {
      // Get the operation type
      const methodProperty = propertyType.getProperty(httpMethod);
      if (!methodProperty) {
        continue;
      }
      if (methodProperty.getTypeAtLocation(property).getText() === "never") {
        continue;
      }

      const commentLines: string[] = [];
      let paramsType: string | null = null;
      let requestBodyType: string | null = null;

      const declarations = methodProperty.getDeclarations();
      if (declarations.length <= 0) {
        continue;
      }
      const decl = declarations[0];

      if (!Node.isPropertySignature(decl)) {
        continue;
      }

      const paramProp = decl.getType().getPropertyOrThrow("parameters");
      const paramTypes = paramProp
        .getTypeAtLocation(decl)
        .getProperties()
        .map((prop) => {
          const propType = prop.getTypeAtLocation(decl);
          const typeText = propType.getText();
          if (typeText === "never") {
            return "";
          }
          return `${prop.getName()}: ${typeText}`;
        })
        .filter((typeText) => typeText !== "")
        .join(", ");
      if (paramTypes !== "") {
        paramsType = `{${paramTypes}}`;
      }

      const requestBodyProp = decl.getType().getProperty("requestBody");
      if (requestBodyProp) {
        const t = requestBodyProp.getTypeAtLocation(decl);
        if (t.getText() !== "never") {
          const contentProp = t.getPropertyOrThrow("content");
          const contentType = contentProp.getTypeAtLocation(decl);
          const contentTypeProps = contentType.getProperties();

          if (contentTypeProps.length > 0 && contentTypeProps[0]) {
            requestBodyType = contentTypeProps[0].getTypeAtLocation(decl).getText();
          }
        }
      }

      if ("getJsDocs" in decl && typeof decl.getJsDocs === "function") {
        const jsDocs = decl.getJsDocs();
        for (const d of jsDocs) {
          const description = d.getDescription().trim();
          if (description) {
            commentLines.push(`* ${description}`);
          }
        }
      }

      const sanitizedPath = path
        .replace(/[{}]/g, "")
        .replace(/[-/.]/g, "_")
        .replace(/^_/, ""); // Remove leading underscore if present

      // Generate a camelCase operation name
      const pathSegments = sanitizedPath.split("_");
      const camelCasePath = pathSegments
        .map((segment, index) => {
          // First segment is lowercase, rest are capitalized
          if (index === 0) return segment.toLowerCase();
          return (
            segment.charAt(0).toUpperCase() + segment.slice(1).toLowerCase()
          );
        })
        .join("");

      const operationName = `${httpMethod}${camelCasePath.charAt(0).toUpperCase()}${camelCasePath.slice(1)}`;

      endpoints.push({
        path,
        httpMethod,
        operationName,
        commentLines,
        paramsType,
        bodyType: requestBodyType,
      });
    }
  }

  return endpoints;
}

function generateClientClass(endpoints: EndpointInfo[]): string {
  const classCode = [
    "export class Client {",
    "    private readonly client;",
    "",
    "    constructor(clientOptions: ClientOptions) {",
    "        this.client = createClient<paths>(clientOptions);",
    "    }",
    "",
  ];

  // Generate class methods for each endpoint
  for (const endpoint of endpoints) {
    const {
      path,
      httpMethod,
      operationName,
      commentLines,
      paramsType,
      bodyType,
    } = endpoint;

    // Add JSDoc comment if available
    if (commentLines.length > 0) {
      classCode.push("    /**");
      for (const line of commentLines) {
        classCode.push(`     ${line}`);
      }
      classCode.push("     */");
    }

    // Method signature
    classCode.push(`    async ${operationName}(`);

    // Add method parameters with proper indentation
    const paramsList = [];
    if (paramsType) {
      paramsList.push(`params: ${paramsType}`);
    }

    if (bodyType) {
      // Properly indent the body by ensuring it starts with correct indentation
      paramsList.push(`body: ${bodyType}`);
    }

    if (paramsList.length > 0) {
      classCode.push(paramsList.join(",\n"));
    }

    classCode.push(
      "    ) {"
    );

    // Method body
    classCode.push(
      `        return await this.client.${httpMethod.toUpperCase()}("${path}", {`,
    );

    if (paramsType) {
      classCode.push("            params,");
    }

    if (bodyType) {
      classCode.push("            body,");
    }

    classCode.push("        });");
    classCode.push("    }");
    classCode.push("");
  }

  classCode.push("}");
  classCode.push("");

  return classCode.join("\n");
}
