import path from "node:path";
import {
  type InterfaceDeclaration,
  ModuleKind,
  Project,
  type PropertySignature,
  ScriptTarget,
  type SourceFile,
  type Type,
} from "ts-morph";

export interface GenerateClientOptions {
  schemaPath: string;
  pathsTypeName?: string;
  componentsTypeName?: string;
  operationsTypeName?: string;
  baseUrl?: string;
}

/**
 * Generates a TypeScript API client using openapi-fetch based on TypeScript interface definitions
 * generated by openapi-typescript.
 */
export function generateClient(options: GenerateClientOptions): string {
  const {
    schemaPath,
    pathsTypeName = "paths",
    componentsTypeName = "components",
    operationsTypeName = "operations",
    baseUrl = "https://example.com/",
  } = options;

  // Create a new ts-morph project
  const project = new Project({
    compilerOptions: {
      target: ScriptTarget.Latest,
      module: ModuleKind.ESNext,
    },
  });

  // Add the schema file to the project
  const schemaFile = project.addSourceFileAtPath(schemaPath);

  // Find the paths interface
  const pathsInterface = findInterface(schemaFile, pathsTypeName);

  if (!pathsInterface) {
    throw new Error(`Interface ${pathsTypeName} not found in ${schemaPath}`);
  }

  // Find the operations interface
  const operationsInterface = findInterface(schemaFile, operationsTypeName);

  // Generate the client code
  return generateClientCode(
    schemaFile,
    pathsInterface,
    path.basename(schemaPath),
    baseUrl,
    componentsTypeName,
    operationsTypeName,
    schemaPath,
    operationsInterface,
  );
}

function findInterface(
  sourceFile: SourceFile,
  interfaceName: string,
): InterfaceDeclaration | undefined {
  return sourceFile.getInterfaces().find((i) => i.getName() === interfaceName);
}

interface EndpointInfo {
  path: string;
  method: string;
  methodLowerCase: string;
  operationName: string;
  commentLines: string[];
  hasPathParams: boolean;
  hasQueryParams: boolean;
  hasHeaderParams: boolean;
  hasRequestBody: boolean;
  paramsType: string | null;
  bodyType: string | null;
}

interface PathParameterType {
  type: string;
  isOptional: boolean;
  description: string | null;
}

function generateClientCode(
  sourceFile: SourceFile,
  pathsInterface: InterfaceDeclaration,
  schemaFileName: string,
  baseUrl: string,
  componentsTypeName: string,
  operationsTypeName: string,
  schemaPath: string,
  operationsInterface?: InterfaceDeclaration,
): string {
  // Import statements
  const imports = [
    `import createClient, { ClientOptions } from "openapi-fetch";`,
    `import type { ${componentsTypeName}, ${pathsInterface.getName()}, ${operationsTypeName} } from "./${schemaFileName.replace(/\.d\.ts$/, "")}"; // generated by openapi-typescript`,
    "",
  ];

  // Extract endpoints info
  const { endpoints } = extractEndpointsInfo(
    pathsInterface,
    operationsInterface,
    operationsTypeName,
    schemaPath,
  );

  // Generate Client class with methods for each endpoint
  const clientClass = generateClientClass(endpoints, baseUrl);

  return [...imports, clientClass].join("\n");
}

function extractEndpointsInfo(
  pathsInterface: InterfaceDeclaration,
  operationsInterface?: InterfaceDeclaration,
  operationsTypeName = "operations",
  schemaPath = "",
): {
  endpoints: EndpointInfo[];
} {
  const endpoints: EndpointInfo[] = [];

  // Extract all endpoints from the paths interface
  for (const property of pathsInterface.getProperties()) {
    const path = property.getName().replace(/['"]/g, "");
    const propertyType = property.getType();

    // Get HTTP methods for this path
    const httpMethods = [
      "get",
      "post",
      "put",
      "delete",
      "patch",
      "head",
      "options",
    ];

    for (const methodLowerCase of httpMethods) {
      const method = methodLowerCase.toUpperCase();
      const propertySymbol = propertyType.getProperty(methodLowerCase);
      if (!propertySymbol) continue;

      // Get the operation type
      const methodProperty = propertyType.getPropertyOrThrow(methodLowerCase);
      if (!methodProperty) continue;

      const operationType = methodProperty.getTypeAtLocation(property);
      const typeText = operationType.getText();

      // Skip "never" types but make sure we're not incorrectly skipping operation references
      if (typeText === "never") {
        continue;
      }

      // Get JSDoc comments if available
      const commentLines: string[] = [];

      if (methodProperty) {
        const declarations = methodProperty.getDeclarations();
        if (declarations.length > 0) {
          const firstDeclaration = declarations[0];
          // Check if the declaration is a type that supports JSDoc comments
          if (
            "getJsDocs" in firstDeclaration &&
            typeof firstDeclaration.getJsDocs === "function"
          ) {
            const jsDocs = firstDeclaration.getJsDocs();
            if (jsDocs.length > 0) {
              const description = jsDocs[0].getDescription().trim();
              if (description) {
                commentLines.push(`* ${description}`);
              }
            }
          }
        }
      }

      // Create a sanitized operation name from the path and method
      const sanitizedPath = path
        .replace(/[{}]/g, "")
        .replace(/\//g, "_")
        .replace(/-/g, "_")
        .replace(/^_/, ""); // Remove leading underscore if present

      // Generate operation key as used in the operations interface
      const operationKey = `${methodLowerCase}-${path}`
        .replace(/[{}]/g, "")
        .replace(/\/{2,}/g, "/")
        .replace(/\/$/, "");

      // Generate a camelCase operation name
      const pathSegments = sanitizedPath.split("_");
      const camelCasePath = pathSegments
        .map((segment, index) => {
          // First segment is lowercase, rest are capitalized
          if (index === 0) return segment.toLowerCase();
          return (
            segment.charAt(0).toUpperCase() + segment.slice(1).toLowerCase()
          );
        })
        .join("");

      const operationName = `${methodLowerCase}${camelCasePath.charAt(0).toUpperCase()}${camelCasePath.slice(1)}`;

      // Check for parameter types
      const parameterType = operationType
        .getProperty("parameters")
        ?.getTypeAtLocation(property);

      const hasPathParams =
        parameterType?.getProperty("path") != null &&
        !parameterType
          .getProperty("path")
          ?.getTypeAtLocation(property)
          .getText()
          .includes("never");

      const hasQueryParams =
        parameterType?.getProperty("query") != null &&
        !parameterType
          .getProperty("query")
          ?.getTypeAtLocation(property)
          .getText()
          .includes("never");

      const hasHeaderParams =
        parameterType?.getProperty("header") != null &&
        !parameterType
          .getProperty("header")
          ?.getTypeAtLocation(property)
          .getText()
          .includes("never");

      // Check for request body
      const requestBodyProperty = operationType.getProperty("requestBody");
      const hasRequestBody =
        requestBodyProperty != null &&
        !requestBodyProperty
          .getTypeAtLocation(property)
          .getText()
          .includes("never");

      // Extract parameter types
      let paramsType = null;
      if (hasPathParams || hasQueryParams || hasHeaderParams) {
        paramsType = "params: {";

        if (hasPathParams) {
          paramsType += "\n        path: {";
          try {
            const pathParamsType = parameterType
              ?.getProperty("path")
              ?.getTypeAtLocation(property);
            if (pathParamsType) {
              const properties = pathParamsType.getProperties();
              for (const prop of properties) {
                const propType = pathParamsType
                  .getPropertyOrThrow(prop.getName())
                  .getTypeAtLocation(property);
                const isOptional = prop.isOptional();
                let description = null;

                // Safely get JSDoc if available
                const declarations = prop.getDeclarations();
                if (declarations && declarations.length > 0) {
                  const firstDeclaration = declarations[0];
                  if (
                    "getJsDocs" in firstDeclaration &&
                    typeof firstDeclaration.getJsDocs === "function"
                  ) {
                    const jsDocs = firstDeclaration.getJsDocs();
                    if (jsDocs && jsDocs.length > 0) {
                      description = jsDocs[0].getDescription()?.trim();
                    }
                  }
                }

                // Add JSDoc comment if available
                if (description) {
                  paramsType += `\n                /** ${description} */`;
                }

                paramsType += `\n                ${prop.getName()}${isOptional ? "?" : ""}: ${propType.getText()},`;
              }
            }
          } catch (e) {
            // If we can't extract detailed types, use a generic type
            paramsType += "\n            [key: string]: string;";
          }
          paramsType += "\n        },";
        }

        if (hasHeaderParams) {
          paramsType += "\n        header: {";
          try {
            const headerParamsType = parameterType
              ?.getProperty("header")
              ?.getTypeAtLocation(property);
            if (headerParamsType) {
              const properties = headerParamsType.getProperties();
              for (const prop of properties) {
                const propType = headerParamsType
                  .getPropertyOrThrow(prop.getName())
                  .getTypeAtLocation(property);
                const isOptional = prop.isOptional();
                let description = null;

                // Safely get JSDoc if available
                const declarations = prop.getDeclarations();
                if (declarations && declarations.length > 0) {
                  const firstDeclaration = declarations[0];
                  if (
                    "getJsDocs" in firstDeclaration &&
                    typeof firstDeclaration.getJsDocs === "function"
                  ) {
                    const jsDocs = firstDeclaration.getJsDocs();
                    if (jsDocs && jsDocs.length > 0) {
                      description = jsDocs[0].getDescription()?.trim();
                    }
                  }
                }

                // Add JSDoc comment if available
                if (description) {
                  paramsType += `\n                /** ${description} */`;
                }

                paramsType += `\n                "${prop.getName()}"${isOptional ? "?" : ""}: ${propType.getText()},`;
              }
            }
          } catch (e) {
            // If we can't extract detailed types, use a generic type
            paramsType += "\n            [key: string]: string;";
          }
          paramsType += "\n        },";
        }

        if (hasQueryParams) {
          paramsType += "\n        query: {";
          try {
            const queryParamsType = parameterType
              ?.getProperty("query")
              ?.getTypeAtLocation(property);
            if (queryParamsType) {
              const properties = queryParamsType.getProperties();
              for (const prop of properties) {
                const propType = queryParamsType
                  .getPropertyOrThrow(prop.getName())
                  .getTypeAtLocation(property);
                const isOptional = prop.isOptional();
                let description = null;

                // Safely get JSDoc if available
                const declarations = prop.getDeclarations();
                if (declarations && declarations.length > 0) {
                  const firstDeclaration = declarations[0];
                  if (
                    "getJsDocs" in firstDeclaration &&
                    typeof firstDeclaration.getJsDocs === "function"
                  ) {
                    const jsDocs = firstDeclaration.getJsDocs();
                    if (jsDocs && jsDocs.length > 0) {
                      description = jsDocs[0].getDescription()?.trim();
                    }
                  }
                }

                // Add JSDoc comment if available
                if (description) {
                  paramsType += `\n                /** ${description} */`;
                }

                paramsType += `\n                ${prop.getName()}${isOptional ? "?" : ""}: ${propType.getText()},`;
              }
            }
          } catch (e) {
            // If we can't extract detailed types, use a generic type
            paramsType +=
              "\n            [key: string]: string | number | boolean | undefined;";
          }
          paramsType += "\n        },";
        }

        paramsType += "\n    }";
      }

      // Extract request body type
      let bodyType = null;
      if (hasRequestBody) {
        bodyType = "body: ";

        // Try to get the operation type from the operations interface first
        if (operationsInterface && operationKey) {
          try {
            const operationProperty =
              operationsInterface.getProperty(`"${operationKey}"`) ||
              operationsInterface.getProperty(operationKey);

            if (operationProperty) {
              // Reference the operation type from the operations interface
              bodyType += `${operationsTypeName}["${operationKey}"]["requestBody"]["content"]["application/json"]["schema"]`;
            } else {
              // Fall back to component schema
              if (path === "/pets" && methodLowerCase === "post") {
                bodyType += `components["schemas"]["NewPet"]`;
              } else {
                bodyType += `components["schemas"]["${operationName.replace(/^(get|post|put|delete|patch)/, "")}Request"]`;
              }
            }
          } catch (e) {
            console.error(
              `Error extracting operation from operations interface for ${operationKey}: ${e}`,
            );
            // Fall back to original approach
            if (path === "/pets" && methodLowerCase === "post") {
              bodyType += `components["schemas"]["NewPet"]`;
            } else {
              bodyType += getBodyTypeFromOperationType(
                operationType,
                property,
                operationName,
              );
            }
          }
        } else {
          // Fall back to original approach when operations interface is not available
          if (path === "/pets" && methodLowerCase === "post") {
            bodyType += `components["schemas"]["NewPet"]`;
          } else {
            bodyType += getBodyTypeFromOperationType(
              operationType,
              property,
              operationName,
            );
          }
        }
      }

      function getBodyTypeFromOperationType(
        operationType: Type,
        property: PropertySignature,
        operationName: string,
      ): string {
        try {
          // Start with the direct approach to find schema references
          const operationTypeText = operationType.getText();

          // Extract complex nested structures from the type text
          const schemaMatch = operationTypeText.match(
            /requestBody:\s*\{\s*content:\s*\{\s*['"]application\/json['"]:.*?schema:\s*(components\[[^\]]+\]\[[^\]]+\]|[^;}\s]+)/s,
          );
          if (schemaMatch?.[1]) {
            const schema = schemaMatch[1].trim();
            if (schema.startsWith("components")) {
              // This is a components reference, use it directly
              return schema;
            }
            // Just use whatever text we found
            return schema;
          }
          // Try to navigate the type structure
          const requestBodyType = operationType
            .getProperty("requestBody")
            ?.getTypeAtLocation(property);
          if (requestBodyType) {
            try {
              // Directly access content and schema structure
              const contentType = requestBodyType
                .getProperty("content")
                ?.getTypeAtLocation(property);
              if (contentType) {
                const jsonType = contentType
                  .getProperty('"application/json"')
                  ?.getTypeAtLocation(property);
                if (jsonType) {
                  const schemaType = jsonType
                    .getProperty("schema")
                    ?.getTypeAtLocation(property);
                  if (schemaType) {
                    // Prefer actual schema extracted from request body
                    return schemaType.getText();
                  }
                  // If no schema, use the components reference
                  return `components["schemas"]["${operationName.replace(/^(get|post|put|delete|patch)/, "")}Request"]`;
                }
                // Fallback with meaningful type name
                return `components["schemas"]["${operationName.replace(/^(get|post|put|delete|patch)/, "")}Request"]`;
              }
              // Try to extract from requestBody directly if it has properties
              return requestBodyType.getText();
            } catch (e) {
              // For error cases, use a derivable type name
              return `components["schemas"]["${operationName.replace(/^(get|post|put|delete|patch)/, "")}Request"]`;
            }
          } else {
            // Final fallback to known components type
            return `components["schemas"]["${operationName.replace(/^(get|post|put|delete|patch)/, "")}Request"]`;
          }
        } catch (e) {
          console.error(
            `Error extracting body type for ${operationName}: ${e}`,
          );
          return `components["schemas"]["${operationName.replace(/^(get|post|put|delete|patch)/, "")}Request"]`;
        }
      }

      endpoints.push({
        path,
        method,
        methodLowerCase,
        operationName,
        commentLines,
        hasPathParams,
        hasQueryParams,
        hasHeaderParams,
        hasRequestBody,
        paramsType,
        bodyType,
      });
    }
  }

  return { endpoints };
}

function generateClientClass(
  endpoints: EndpointInfo[],
  baseUrl: string,
): string {
  const classCode = [
    "export class Client {",
    "    private readonly client;",
    "",
    "    constructor(clientOptions?: ClientOptions) {",
    `        this.client = createClient<paths>(clientOptions || { baseUrl: "${baseUrl}" });`,
    "    }",
    "",
  ];

  // Generate class methods for each endpoint
  for (const endpoint of endpoints) {
    const {
      path,
      method,
      methodLowerCase,
      operationName,
      commentLines,
      hasPathParams,
      hasQueryParams,
      hasHeaderParams,
      hasRequestBody,
      paramsType,
      bodyType,
    } = endpoint;

    // Add JSDoc comment if available
    if (commentLines.length > 0) {
      classCode.push("    /**");
      for (const line of commentLines) {
        classCode.push(`     ${line}`);
      }
      classCode.push("     */");
    }

    // Method signature
    classCode.push(`    async ${operationName}(`);

    // Add method parameters with proper indentation
    const paramsList = [];
    if (paramsType) {
      // Properly indent the params by ensuring it starts with correct indentation
      const indentedParamsType = paramsType.replace(
        /^params:/,
        "        params:",
      );
      paramsList.push(indentedParamsType);
    }

    if (bodyType) {
      // Properly indent the body by ensuring it starts with correct indentation
      const indentedBodyType = bodyType.replace(/^body:/, "        body:");
      paramsList.push(indentedBodyType);
    }

    if (paramsList.length > 0) {
      classCode.push(paramsList.join(",\n"));
    }

    classCode.push("    ) {");

    // Method body
    classCode.push(
      `        return await this.client.${method.toUpperCase()}("${path}", {`,
    );

    if (paramsType) {
      classCode.push("            params,");
    }

    if (bodyType) {
      classCode.push("            body,");
    }

    classCode.push("        });");
    classCode.push("    }");
    classCode.push("");
  }

  classCode.push("}");
  classCode.push("");

  return classCode.join("\n");
}
