import { Project, ScriptTarget, ModuleKind, SourceFile, Type, InterfaceDeclaration, PropertySignature } from 'ts-morph';
import path from 'path';

export interface GenerateClientOptions {
  schemaPath: string;
  pathsTypeName?: string;
  componentsTypeName?: string;
  baseUrl?: string;
}

/**
 * Generates a TypeScript API client using openapi-fetch based on TypeScript interface definitions
 * generated by openapi-typescript.
 */
export function generateClient(options: GenerateClientOptions): string {
  const { 
    schemaPath, 
    pathsTypeName = 'paths', 
    componentsTypeName = 'components',
    baseUrl = 'https://example.com/' 
  } = options;
  
  // Create a new ts-morph project
  const project = new Project({
    compilerOptions: {
      target: ScriptTarget.Latest,
      module: ModuleKind.ESNext,
    },
  });
  
  // Add the schema file to the project
  const schemaFile = project.addSourceFileAtPath(schemaPath);
  
  // Find the paths interface
  const pathsInterface = findInterface(schemaFile, pathsTypeName);
  
  if (!pathsInterface) {
    throw new Error(`Interface ${pathsTypeName} not found in ${schemaPath}`);
  }
  
  // Generate the client code
  return generateClientCode(
    schemaFile, 
    pathsInterface, 
    path.basename(schemaPath),
    baseUrl,
    componentsTypeName
  );
}

function findInterface(sourceFile: SourceFile, interfaceName: string): InterfaceDeclaration | undefined {
  return sourceFile.getInterfaces().find(i => i.getName() === interfaceName);
}

interface EndpointInfo {
  path: string;
  method: string;
  methodLowerCase: string;
  operationName: string;
  commentLines: string[];
  hasPathParams: boolean;
  hasQueryParams: boolean;
  hasHeaderParams: boolean;
  hasRequestBody: boolean;
  paramsType: string | null;
  bodyType: string | null;
}

interface PathParameterType {
  type: string;
  isOptional: boolean;
  description: string | null;
}

function generateClientCode(
  sourceFile: SourceFile,
  pathsInterface: InterfaceDeclaration,
  schemaFileName: string,
  baseUrl: string,
  componentsTypeName: string
): string {
  // Import statements
  const imports = [
    `import createClient, { ClientOptions } from "openapi-fetch";`,
    `import type { ${componentsTypeName}, ${pathsInterface.getName()} } from "./${schemaFileName.replace(/\.d\.ts$/, '')}"; // generated by openapi-typescript`,
    ``,
  ];
  
  // Extract endpoints info
  const { endpoints } = extractEndpointsInfo(pathsInterface);
  
  // Generate Client class with methods for each endpoint
  const clientClass = generateClientClass(endpoints, baseUrl);
  
  return [...imports, clientClass].join('\n');
}

function extractEndpointsInfo(pathsInterface: InterfaceDeclaration): { 
  endpoints: EndpointInfo[];
} {
  const endpoints: EndpointInfo[] = [];
  
  // Extract all endpoints from the paths interface
  for (const property of pathsInterface.getProperties()) {
    const path = property.getName().replace(/['"]/g, '');
    const propertyType = property.getType();
    
    // Get HTTP methods for this path
    const httpMethods = ['get', 'post', 'put', 'delete', 'patch', 'head', 'options'];
    
    for (const methodLowerCase of httpMethods) {
      const method = methodLowerCase.toUpperCase();
      const propertySymbol = propertyType.getProperty(methodLowerCase);
      if (!propertySymbol) continue;
      
      // Get the operation type
      const methodProperty = propertyType.getPropertyOrThrow(methodLowerCase);
      if (!methodProperty) continue;
      
      const operationType = methodProperty.getTypeAtLocation(property);
      const typeText = operationType.getText();
      
      // Skip "never" types but make sure we're not incorrectly skipping operation references
      if (typeText === 'never') {
        continue;
      }
      
      // Get JSDoc comments if available
      const commentLines: string[] = [];
      
      if (methodProperty) {
        const declarations = methodProperty.getDeclarations();
        if (declarations.length > 0) {
          const firstDeclaration = declarations[0];
          // Check if the declaration is a type that supports JSDoc comments
          if ('getJsDocs' in firstDeclaration && typeof firstDeclaration.getJsDocs === 'function') {
            const jsDocs = firstDeclaration.getJsDocs();
            if (jsDocs.length > 0) {
              const description = jsDocs[0].getDescription().trim();
              if (description) {
                commentLines.push(`* ${description}`);
              }
            }
          }
        }
      }
      
      // Create a sanitized operation name from the path and method
      const sanitizedPath = path
        .replace(/[{}]/g, '')
        .replace(/\//g, '_')
        .replace(/-/g, '_')
        .replace(/^_/, ''); // Remove leading underscore if present
      
      // Generate a camelCase operation name
      const pathSegments = sanitizedPath.split('_');
      const camelCasePath = pathSegments
        .map((segment, index) => {
          // First segment is lowercase, rest are capitalized
          if (index === 0) return segment.toLowerCase();
          return segment.charAt(0).toUpperCase() + segment.slice(1).toLowerCase();
        })
        .join('');
      
      const operationName = `${methodLowerCase}${camelCasePath.charAt(0).toUpperCase()}${camelCasePath.slice(1)}`;
      
      // Check for parameter types
      const parameterType = operationType.getProperty('parameters')?.getTypeAtLocation(property);
      
      const hasPathParams = parameterType?.getProperty('path') != null && 
        !parameterType.getProperty('path')?.getTypeAtLocation(property).getText().includes('never');
        
      const hasQueryParams = parameterType?.getProperty('query') != null && 
        !parameterType.getProperty('query')?.getTypeAtLocation(property).getText().includes('never');
        
      const hasHeaderParams = parameterType?.getProperty('header') != null && 
        !parameterType.getProperty('header')?.getTypeAtLocation(property).getText().includes('never');
      
      // Check for request body
      const hasRequestBody = operationType.getProperty('requestBody') != null && 
        !operationType.getProperty('requestBody')?.getTypeAtLocation(property).getText().includes('never');
      
      // Extract parameter types
      let paramsType = null;
      if (hasPathParams || hasQueryParams || hasHeaderParams) {
        paramsType = 'params: {';
        
        if (hasPathParams) {
          paramsType += '\n        path: {';
          try {
            const pathParamsType = parameterType?.getProperty('path')?.getTypeAtLocation(property);
            if (pathParamsType) {
              const properties = pathParamsType.getProperties();
              for (const prop of properties) {
                const propType = pathParamsType.getPropertyOrThrow(prop.getName()).getTypeAtLocation(property);
                const isOptional = prop.isOptional();
                let description = null;
                
                // Safely get JSDoc if available
                const declarations = prop.getDeclarations();
                if (declarations && declarations.length > 0) {
                  const firstDeclaration = declarations[0];
                  if ('getJsDocs' in firstDeclaration && typeof firstDeclaration.getJsDocs === 'function') {
                    const jsDocs = firstDeclaration.getJsDocs();
                    if (jsDocs && jsDocs.length > 0) {
                      description = jsDocs[0].getDescription()?.trim();
                    }
                  }
                }
                
                // Add JSDoc comment if available
                if (description) {
                  paramsType += `\n                /** ${description} */`;
                }
                
                paramsType += `\n                ${prop.getName()}${isOptional ? '?' : ''}: ${propType.getText()},`;
              }
            }
          } catch (e) {
            // If we can't extract detailed types, use a generic type
            paramsType += '\n            [key: string]: string;';
          }
          paramsType += '\n        },';
        }
        
        if (hasHeaderParams) {
          paramsType += '\n        header: {';
          try {
            const headerParamsType = parameterType?.getProperty('header')?.getTypeAtLocation(property);
            if (headerParamsType) {
              const properties = headerParamsType.getProperties();
              for (const prop of properties) {
                const propType = headerParamsType.getPropertyOrThrow(prop.getName()).getTypeAtLocation(property);
                const isOptional = prop.isOptional();
                let description = null;
                
                // Safely get JSDoc if available
                const declarations = prop.getDeclarations();
                if (declarations && declarations.length > 0) {
                  const firstDeclaration = declarations[0];
                  if ('getJsDocs' in firstDeclaration && typeof firstDeclaration.getJsDocs === 'function') {
                    const jsDocs = firstDeclaration.getJsDocs();
                    if (jsDocs && jsDocs.length > 0) {
                      description = jsDocs[0].getDescription()?.trim();
                    }
                  }
                }
                
                // Add JSDoc comment if available
                if (description) {
                  paramsType += `\n                /** ${description} */`;
                }
                
                paramsType += `\n                "${prop.getName()}"${isOptional ? '?' : ''}: ${propType.getText()},`;
              }
            }
          } catch (e) {
            // If we can't extract detailed types, use a generic type
            paramsType += '\n            [key: string]: string;';
          }
          paramsType += '\n        },';
        }
        
        if (hasQueryParams) {
          paramsType += '\n        query: {';
          try {
            const queryParamsType = parameterType?.getProperty('query')?.getTypeAtLocation(property);
            if (queryParamsType) {
              const properties = queryParamsType.getProperties();
              for (const prop of properties) {
                const propType = queryParamsType.getPropertyOrThrow(prop.getName()).getTypeAtLocation(property);
                const isOptional = prop.isOptional();
                let description = null;
                
                // Safely get JSDoc if available
                const declarations = prop.getDeclarations();
                if (declarations && declarations.length > 0) {
                  const firstDeclaration = declarations[0];
                  if ('getJsDocs' in firstDeclaration && typeof firstDeclaration.getJsDocs === 'function') {
                    const jsDocs = firstDeclaration.getJsDocs();
                    if (jsDocs && jsDocs.length > 0) {
                      description = jsDocs[0].getDescription()?.trim();
                    }
                  }
                }
                
                // Add JSDoc comment if available
                if (description) {
                  paramsType += `\n                /** ${description} */`;
                }
                
                paramsType += `\n                ${prop.getName()}${isOptional ? '?' : ''}: ${propType.getText()},`;
              }
            }
          } catch (e) {
            // If we can't extract detailed types, use a generic type
            paramsType += '\n            [key: string]: string | number | boolean | undefined;';
          }
          paramsType += '\n        },';
        }
        
        paramsType += '\n    }';
      }
      
      // Extract request body type
      let bodyType = null;
      if (hasRequestBody) {
        bodyType = 'body: ';
        try {
          const requestBodyType = operationType.getProperty('requestBody')?.getTypeAtLocation(property);
          const contentType = requestBodyType?.getProperty('content')?.getTypeAtLocation(property);
          const jsonType = contentType?.getProperty('"application/json"')?.getTypeAtLocation(property);
          
          if (jsonType && jsonType.getProperties().length > 0) {
            bodyType += '{';
            const properties = jsonType.getProperties();
            for (const prop of properties) {
              const propType = jsonType.getPropertyOrThrow(prop.getName()).getTypeAtLocation(property);
              const isOptional = prop.isOptional();
              let description = null;
              
              // Safely get JSDoc if available
              const declarations = prop.getDeclarations();
              if (declarations && declarations.length > 0) {
                const firstDeclaration = declarations[0];
                if ('getJsDocs' in firstDeclaration && typeof firstDeclaration.getJsDocs === 'function') {
                  const jsDocs = firstDeclaration.getJsDocs();
                  if (jsDocs && jsDocs.length > 0) {
                    description = jsDocs[0].getDescription()?.trim();
                  }
                }
              }
              
              // Add JSDoc comment if available
              if (description) {
                bodyType += `\n            /** ${description} */`;
              }
              
              bodyType += `\n            ${prop.getName()}${isOptional ? '?' : ''}: ${propType.getText()},`;
            }
            bodyType += '\n        }';
          } else {
            // Try to extract the type directly if possible
            const jsonTypeText = jsonType?.getText();
            if (jsonTypeText && !jsonTypeText.includes('unknown') && jsonTypeText !== '{}') {
              bodyType += jsonTypeText;
            } else {
              // If we can't extract detailed types, use a generic type
              bodyType += 'Record<string, any>';
            }
          }
        } catch (e) {
          // If we can't extract detailed types, use a generic type
          bodyType += 'Record<string, any>';
        }
      }
      
      endpoints.push({
        path,
        method,
        methodLowerCase,
        operationName,
        commentLines,
        hasPathParams,
        hasQueryParams,
        hasHeaderParams,
        hasRequestBody,
        paramsType,
        bodyType
      });
    }
  }
  
  return { endpoints };
}

function generateClientClass(endpoints: EndpointInfo[], baseUrl: string): string {
  const classCode = [
    `export class Client {`,
    `    private readonly client;`,
    ``,
    `    constructor(clientOptions?: ClientOptions) {`,
    `        this.client = createClient<paths>(clientOptions || { baseUrl: "${baseUrl}" });`,
    `    }`,
    ``
  ];
  
  // Generate class methods for each endpoint
  for (const endpoint of endpoints) {
    const { 
      path, 
      method, 
      methodLowerCase, 
      operationName, 
      commentLines, 
      hasPathParams, 
      hasQueryParams, 
      hasHeaderParams, 
      hasRequestBody,
      paramsType,
      bodyType
    } = endpoint;
    
    // Add JSDoc comment if available
    if (commentLines.length > 0) {
      classCode.push(`    /**`);
      commentLines.forEach(line => classCode.push(`     ${line}`));
      classCode.push(`     */`);
    }
    
    // Method signature
    classCode.push(`    async ${operationName}(`);
    
    // Add method parameters with proper indentation
    let paramsList = [];
    if (paramsType) {
      // Properly indent the params by ensuring it starts with correct indentation
      const indentedParamsType = paramsType.replace(/^params:/, '        params:');
      paramsList.push(indentedParamsType);
    }
    
    if (bodyType) {
      // Properly indent the body by ensuring it starts with correct indentation
      const indentedBodyType = bodyType.replace(/^body:/, '        body:');
      paramsList.push(indentedBodyType);
    }
    
    if (paramsList.length > 0) {
      classCode.push(paramsList.join(',\n'));
    }
    
    classCode.push(`    ) {`);
    
    // Method body
    classCode.push(`        return await this.client.${method.toUpperCase()}("${path}", {`);
    
    if (paramsType) {
      classCode.push(`            params,`);
    }
    
    if (bodyType) {
      classCode.push(`            body,`);
    }
    
    classCode.push(`        });`);
    classCode.push(`    }`);
    classCode.push(``);
  }
  
  classCode.push(`}`);
  classCode.push(``);
  
  return classCode.join('\n');
}